#pragma once

#include "megdnn/arch.h"
#include "megdnn/internal/defs.h"
#include "src/cambricon/utils.mlu.h"

namespace megdnn {
namespace cambricon {
namespace indexing_multi_axis_vec {

struct OprIncrCommon {};

//! modified from KAxisIndexer of CUDA
template <int idx_ndim>
struct KAxisIndexer {
    int stride[idx_ndim];
#ifdef WIN32
    uint32_t shape[idx_ndim];
#else
    // original shape[0] not storaged
    uint32_t shape[idx_ndim - 1];
#endif
    const int* ptr;
};

//! modified from KAxisIndexer of CUDA
//! param for gen_offset_base
template <int nidx, int idx_ndim>
struct GenOffsetBaseParam {
    uint32_t size;  //!< number of outputs; also size of each index
    int* output;    //!< output ptr
    KAxisIndexer<idx_ndim> indexer[nidx];
    uint32_t data_shape[nidx];
    int data_stride[nidx];
    int cluster_count;
    int core_per_cluster;
};

//! modified from FastLayout of CUDA
template <int ndim>
struct SimplifiedLayout {
    int stride[ndim];
#ifdef WIN32
    uint32_t shape[ndim];
#else
    uint32_t shape[ndim - 1];
#endif
};

//! param for apply_opr
template <int ndim>
struct ApplyOprParam {
    uint32_t tot_size;  //!< total output size

    //! offset array generated by gen_offset_base for first output axis
    const int* offset_base;
    void *data, *value;

    // first idx axis
    int idx_axis;
    // last idx axis + 1
    int idx_axis_end;
    // number of elements for idx shape
    int idx_nelems;

    int value_stride;

    //! iterate on value, with strides from corresponding axes on data
    SimplifiedLayout<ndim> value_ly_on_data;

    int cluster_count;
    int core_per_cluster;
};

//! generate offset bases for first axis in the output
template <int nidx, int idx_ndim>
void gen_offset_base(
        const GenOffsetBaseParam<nidx, idx_ndim>& param, cnrtQueue_t queue);

template <typename ctype, int ndim, class Opr>
void apply_opr(const ApplyOprParam<ndim>& param, cnrtQueue_t queue);

template <int ndim, class Opr>
void apply_opr(
        const ApplyOprParam<ndim>& param, cnnlDataType_t cnnl_data_type,
        cnrtQueue_t queue);

}  // namespace indexing_multi_axis_vec
}  // namespace cambricon
}  // namespace megdnn

// vim: ft=cpp syntax=cpp.doxygen
