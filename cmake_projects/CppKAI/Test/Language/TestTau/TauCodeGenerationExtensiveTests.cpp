#include <gtest/gtest.h>
#include <regex>
#include <string>
#include <vector>
#include <sstream>

#include "KAI/Core/Config/Base.h"
#include "KAI/Core/Debug.h"
#include "KAI/Core/Logger.h"
#include "KAI/Language/Tau/Generate/GenerateAgent.h"
#include "KAI/Language/Tau/Generate/GenerateProxy.h"
#include "KAI/Language/Tau/TauParser.h"

using namespace kai;
using namespace std;

/// Comprehensive test fixture for Tau code generation
class TauCodeGenerationExtensiveTests : public ::testing::Test {
protected:
    void SetUp() override {
        // Test setup - no dependencies needed for code generation tests
    }

    /// Helper to generate proxy code from Tau IDL
    bool GenerateProxyCode(const string& tauCode, string& output, string& error) {
        try {
            tau::Generate::GenerateProxy generator(tauCode.c_str(), output);
            if (generator.Failed) {
                error = generator.Error;
                return false;
            }
            return !output.empty();
        } catch (const exception& e) {
            error = e.what();
            return false;
        }
    }

    /// Helper to generate agent code from Tau IDL
    bool GenerateAgentCode(const string& tauCode, string& output, string& error) {
        try {
            tau::Generate::GenerateAgent generator(tauCode.c_str(), output);
            if (generator.Failed) {
                error = generator.Error;
                return false;
            }
            return !output.empty();
        } catch (const exception& e) {
            error = e.what();
            return false;
        }
    }

    /// Helper to check if output contains expected patterns
    bool ContainsPatterns(const string& output, const vector<string>& patterns) {
        for (const auto& pattern : patterns) {
            if (output.find(pattern) == string::npos) {
                return false;
            }
        }
        return true;
    }

    /// Helper to check if output matches regex patterns
    bool MatchesRegexPatterns(const string& output, const vector<string>& regexPatterns) {
        for (const auto& pattern : regexPatterns) {
            regex r(pattern);
            if (!regex_search(output, r)) {
                return false;
            }
        }
        return true;
    }

    /// Helper to count occurrences of a pattern in output
    int CountPatternOccurrences(const string& output, const string& pattern) {
        int count = 0;
        string::size_type pos = 0;
        while ((pos = output.find(pattern, pos)) != string::npos) {
            ++count;
            pos += pattern.length();
        }
        return count;
    }
};

// =============================================================================
// PROXY GENERATION TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, ProxyHeaderGeneration) {
    string tauCode = R"(
        namespace TestNamespace {
            interface ITestService {
                void testMethod();
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, output, error)) << "Error: " << error;

    // Check for proper header structure
    vector<string> expectedHeaders = {
        "// Auto-generated by KAI Tau IDL Code Generator",
        "// DO NOT MODIFY - Changes will be overwritten on next generation",
        "// Generated from Tau interface definition",
        "#pragma once",
        "#include <KAI/Network/ProxyDecl.h>",
        "#include <KAI/Network/NetworkException.h>",
        "#include <functional>",
        "#include <stdexcept>",
        "#include <string>",
        "#include <future>",
        "#include <RakNet/BitStream.h>"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedHeaders)) 
        << "Missing expected header patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, ProxyClassGeneration) {
    string tauCode = R"(
        namespace Services {
            interface ICalculator {
                float add(float a, float b);
                void clear();
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, output, error)) << "Error: " << error;

    // Check for proper class structure
    vector<string> expectedPatterns = {
        "namespace Services",
        "/// Network proxy for ICalculator interface",
        "/// Provides type-safe remote method calls over the network",
        "/// All methods are synchronous and may throw NetworkException on failure",
        "class ICalculatorProxy: public ProxyBase",
        "using ProxyBase::StreamType;",
        "ICalculatorProxy(Node &node, NetHandle handle) : ProxyBase(node, handle) { }"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected class patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, ProxyMethodGeneration) {
    string tauCode = R"(
        namespace Test {
            interface IService {
                int getValue();
                void setValue(int value);
                string processData(const string& input, int flags);
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, output, error)) << "Error: " << error;

    // Check method generation with documentation
    vector<string> expectedPatterns = {
        "/// Remote method call: getValue",
        "/// @return int",
        "/// @throws NetworkException on communication failure",
        "int getValue()",

        "/// Remote method call: setValue", 
        "/// Parameters:",
        "///   @param value int",
        "/// @throws NetworkException on communication failure",
        "void setValue(int value)",

        "/// Remote method call: processData",
        "///   @param input string",
        "///   @param flags int",
        "string processData(const string& input, int flags)"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected method patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, ProxyErrorHandling) {
    string tauCode = R"(
        namespace Test {
            interface IService {
                void send();
                int receive();
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, output, error)) << "Error: " << error;

    // Check for proper error handling
    vector<string> expectedPatterns = {
        "try {",
        "_node->Send(\"send\")",
        "} catch (const std::exception& e) {",
        "throw NetworkException(\"Failed to send 'send': \" + std::string(e.what()))",

        "_node->SendWithResponse(\"receive\")",
        "throw NetworkException(\"Failed to call 'receive': \" + std::string(e.what()))"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected error handling patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, ProxyEventHandling) {
    string tauCode = R"(
        namespace Events {
            interface IEventService {
                void trigger();
                event DataReady(string data, int size);
                event StatusChanged(bool isActive);
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, output, error)) << "Error: " << error;

    // Check for event registration/unregistration methods
    vector<string> expectedPatterns = {
        "void RegisterDataReadyHandler(std::function<void(string, int)> handler)",
        "RegisterEventHandler(\"DataReady\", handler)",
        "void UnregisterDataReadyHandler()",
        "UnregisterEventHandler(\"DataReady\")",

        "void RegisterStatusChangedHandler(std::function<void(bool)> handler)",
        "RegisterEventHandler(\"StatusChanged\", handler)",
        "void UnregisterStatusChangedHandler()",
        "UnregisterEventHandler(\"StatusChanged\")"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected event handling patterns in output:\n" << output;
}

// =============================================================================
// AGENT GENERATION TESTS  
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, AgentHeaderGeneration) {
    string tauCode = R"(
        namespace TestNamespace {
            interface ITestService {
                void testMethod();
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, output, error)) << "Error: " << error;

    // Check for proper header structure
    vector<string> expectedHeaders = {
        "// Auto-generated by KAI Tau IDL Code Generator",
        "// DO NOT MODIFY - Changes will be overwritten on next generation", 
        "// Generated from Tau interface definition",
        "#pragma once",
        "#include <KAI/Network/AgentDecl.h>",
        "#include <KAI/Network/NetworkException.h>",
        "#include <stdexcept>",
        "#include <string>",
        "#include <RakNet/BitStream.h>"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedHeaders))
        << "Missing expected header patterns in agent output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, AgentClassGeneration) {
    string tauCode = R"(
        namespace Services {
            interface ICalculator {
                float add(float a, float b);
                void clear();
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, output, error)) << "Error: " << error;

    // Check for proper agent class structure
    vector<string> expectedPatterns = {
        "namespace Services",
        "/// Network agent for ICalculator interface",
        "/// Handles incoming network requests and dispatches to implementation",
        "/// All handler methods deserialize parameters and call implementation",
        "class ICalculatorAgent: public AgentBase<ICalculator>",
        "ICalculatorAgent(Node &node, NetHandle handle) : AgentBase(node, handle) { }"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected agent class patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, AgentHandlerGeneration) {
    string tauCode = R"(
        namespace Test {
            interface IService {
                int calculate(float input, int mode);
                void reset();
                string getData(int id, bool detailed);
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, output, error)) << "Error: " << error;

    // Check handler method generation with documentation  
    vector<string> expectedPatterns = {
        "/// Handler for remote method call: calculate",
        "/// Deserializes parameters from BitStream and calls implementation",
        "/// Parameters deserialized from network:",
        "///   input (float)",
        "///   mode (int)", 
        "/// Sends int response back to sender",
        "void Handle_calculate(RakNet::BitStream& bs, RakNet::SystemAddress& sender)",

        "float input;",
        "bs >> input;",
        "int mode;", 
        "bs >> mode;",
        "int result = _impl->calculate(input, mode);",
        "RakNet::BitStream response;",
        "response << result;",
        "_node->SendResponse(sender, response);",

        "/// Handler for remote method call: reset",
        "void Handle_reset(RakNet::BitStream& bs, RakNet::SystemAddress& sender)",
        "_impl->reset();"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected handler patterns in output:\n" << output;
}

TEST_F(TauCodeGenerationExtensiveTests, AgentEventTriggers) {
    string tauCode = R"(
        namespace Events {
            interface IEventService {
                void process();
                event DataProcessed(string result, float score, bool success);
                event ErrorOccurred(string message);
            }
        }
    )";

    string output, error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, output, error)) << "Error: " << error;

    // Check for event trigger generation
    vector<string> expectedPatterns = {
        "/// Trigger event: DataProcessed",
        "/// Broadcasts event to all connected clients",
        "/// Event parameters:",
        "///   result (string)",
        "///   score (float)",
        "///   success (bool)",
        "void TriggerDataProcessed(const string& result, float score, bool success)",
        "RakNet::BitStream eventData;",
        "eventData << result;",
        "eventData << score;",
        "eventData << success;",
        "_node->BroadcastEvent(\"DataProcessed\", eventData);",

        "/// Trigger event: ErrorOccurred",
        "void TriggerErrorOccurred(const string& message)",
        "_node->BroadcastEvent(\"ErrorOccurred\", eventData);"
    };

    EXPECT_TRUE(ContainsPatterns(output, expectedPatterns))
        << "Missing expected event trigger patterns in output:\n" << output;
}

// =============================================================================
// PARAMETER TYPE HANDLING TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, PrimitiveTypeParameters) {
    string tauCode = R"(
        namespace Types {
            interface ITypeTest {
                void testPrimitives(int i, float f, bool b, double d, char c);
                int primitiveReturn(float input);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Check proxy uses pass-by-value for primitives
    vector<string> proxyPatterns = {
        "void testPrimitives(int i, float f, bool b, double d, char c)",
        "int primitiveReturn(float input)"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, proxyPatterns))
        << "Proxy primitive parameter handling incorrect:\n" << proxyOutput;

    // Check agent deserializes primitives correctly
    vector<string> agentPatterns = {
        "int i;",
        "bs >> i;",
        "float f;", 
        "bs >> f;",
        "bool b;",
        "bs >> b;",
        "double d;",
        "bs >> d;",
        "char c;",
        "bs >> c;"
    };

    EXPECT_TRUE(ContainsPatterns(agentOutput, agentPatterns))
        << "Agent primitive deserialization incorrect:\n" << agentOutput;
}

TEST_F(TauCodeGenerationExtensiveTests, ComplexTypeParameters) {
    string tauCode = R"(
        namespace Types {
            interface IComplexTest {
                void processString(string data);
                void processArray(Array items);
                string complexReturn(string input, Array config);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Check proxy uses const reference for complex types
    vector<string> proxyPatterns = {
        "void processString(const string& data)",
        "void processArray(const Array& items)",
        "string complexReturn(const string& input, const Array& config)"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, proxyPatterns))
        << "Proxy complex parameter handling incorrect:\n" << proxyOutput;

    // Check agent deserializes complex types correctly
    vector<string> agentPatterns = {
        "string data;",
        "bs >> data;",
        "Array items;",
        "bs >> items;",
        "string input;",
        "Array config;"
    };

    EXPECT_TRUE(ContainsPatterns(agentOutput, agentPatterns))
        << "Agent complex deserialization incorrect:\n" << agentOutput;
}

// =============================================================================
// NAMESPACE AND INHERITANCE TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, NestedNamespaces) {
    string tauCode = R"(
        namespace Outer::Inner::Deep {
            interface INestedService {
                void nestedMethod();
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Both should handle nested namespaces correctly
    vector<string> expectedPatterns = {
        "namespace Outer::Inner::Deep",
        "class INestedServiceProxy",
        "class INestedServiceAgent"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, expectedPatterns))
        << "Proxy nested namespace handling incorrect:\n" << proxyOutput;
    EXPECT_TRUE(ContainsPatterns(agentOutput, expectedPatterns))
        << "Agent nested namespace handling incorrect:\n" << agentOutput;
}

TEST_F(TauCodeGenerationExtensiveTests, MultipleInterfaces) {
    string tauCode = R"(
        namespace Services {
            interface IService1 {
                void method1();
                event Event1(int data);
            }
            
            interface IService2 {
                int method2(string input);
                event Event2(string message);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Check both interfaces are generated
    vector<string> proxyPatterns = {
        "class IService1Proxy",
        "void method1()",
        "void RegisterEvent1Handler",
        "class IService2Proxy",
        "int method2(const string& input)",
        "void RegisterEvent2Handler"
    };

    vector<string> agentPatterns = {
        "class IService1Agent",
        "void Handle_method1",
        "void TriggerEvent1",
        "class IService2Agent", 
        "void Handle_method2",
        "void TriggerEvent2"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, proxyPatterns))
        << "Proxy multiple interface handling incorrect:\n" << proxyOutput;
    EXPECT_TRUE(ContainsPatterns(agentOutput, agentPatterns))
        << "Agent multiple interface handling incorrect:\n" << agentOutput;
}

// =============================================================================
// EDGE CASES AND ERROR HANDLING TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, EmptyInterface) {
    string tauCode = R"(
        namespace Test {
            interface IEmpty {
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Should still generate class structure
    vector<string> expectedPatterns = {
        "class IEmptyProxy",
        "class IEmptyAgent"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, expectedPatterns))
        << "Proxy empty interface handling incorrect:\n" << proxyOutput;
    EXPECT_TRUE(ContainsPatterns(agentOutput, expectedPatterns))
        << "Agent empty interface handling incorrect:\n" << agentOutput;
}

TEST_F(TauCodeGenerationExtensiveTests, VoidMethodsOnly) {
    string tauCode = R"(
        namespace Test {
            interface IVoidService {
                void initialize();
                void process();
                void shutdown();
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Check void methods use Send instead of SendWithResponse in proxy
    EXPECT_TRUE(proxyOutput.find("_node->Send(\"initialize\")") != string::npos)
        << "Proxy void method should use Send:\n" << proxyOutput;
    EXPECT_TRUE(proxyOutput.find("SendWithResponse") == string::npos)
        << "Proxy void methods should not use SendWithResponse:\n" << proxyOutput;

    // Check agent handlers don't send responses for void methods
    EXPECT_TRUE(agentOutput.find("_impl->initialize()") != string::npos)
        << "Agent should call implementation for void methods:\n" << agentOutput;
    EXPECT_TRUE(agentOutput.find("Handle_initialize") != string::npos)
        << "Agent should have handler for void methods:\n" << agentOutput;
}

TEST_F(TauCodeGenerationExtensiveTests, MethodNameEdgeCases) {
    string tauCode = R"(
        namespace Test {
            interface IEdgeCases {
                void _underscore_method();
                int CamelCaseMethod(int paramName);
                float snake_case_method(float param_value);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Check all method name styles are handled correctly
    vector<string> proxyPatterns = {
        "void _underscore_method()",
        "int CamelCaseMethod(int paramName)",
        "float snake_case_method(float param_value)"
    };

    vector<string> agentPatterns = {
        "void Handle__underscore_method",
        "void Handle_CamelCaseMethod", 
        "void Handle_snake_case_method"
    };

    EXPECT_TRUE(ContainsPatterns(proxyOutput, proxyPatterns))
        << "Proxy method name edge cases incorrect:\n" << proxyOutput;
    EXPECT_TRUE(ContainsPatterns(agentOutput, agentPatterns))
        << "Agent method name edge cases incorrect:\n" << agentOutput;
}

// =============================================================================
// INTEGRATION TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, CompleteServiceExample) {
    string tauCode = R"(
        namespace FileService {
            interface IFileManager {
                // File operations
                bool createFile(string path, string content);
                string readFile(string path);
                void deleteFile(string path);
                
                // Directory operations  
                Array listDirectory(string path);
                bool createDirectory(string path);
                
                // Events
                event FileCreated(string path, int size);
                event FileDeleted(string path);
                event DirectoryChanged(string path, Array newContents);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Verify complete service generation
    EXPECT_GT(proxyOutput.length(), 1000) << "Proxy output seems too short";
    EXPECT_GT(agentOutput.length(), 1000) << "Agent output seems too short";

    // Count methods and events
    EXPECT_EQ(CountPatternOccurrences(proxyOutput, "/// Remote method call:"), 5)
        << "Should have 5 method documentations in proxy";
    EXPECT_EQ(CountPatternOccurrences(proxyOutput, "RegisterEventHandler"), 3)
        << "Should have 3 event registrations in proxy";
    
    EXPECT_EQ(CountPatternOccurrences(agentOutput, "void Handle_"), 5)
        << "Should have 5 handler methods in agent";
    EXPECT_EQ(CountPatternOccurrences(agentOutput, "void Trigger"), 3)
        << "Should have 3 event triggers in agent";

    // Verify namespace and class names
    EXPECT_TRUE(ContainsPatterns(proxyOutput, {"namespace FileService", "class IFileManagerProxy"}))
        << "Proxy missing correct namespace/class";
    EXPECT_TRUE(ContainsPatterns(agentOutput, {"namespace FileService", "class IFileManagerAgent"}))
        << "Agent missing correct namespace/class";
}

TEST_F(TauCodeGenerationExtensiveTests, CodeQualityMetrics) {
    string tauCode = R"(
        namespace Quality {
            interface IQualityService {
                int compute(float input, string config);
                event ResultReady(int result, bool success);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Quality metrics checks
    
    // 1. Documentation coverage
    EXPECT_GT(CountPatternOccurrences(proxyOutput, "///"), 10)
        << "Insufficient documentation comments in proxy";
    EXPECT_GT(CountPatternOccurrences(agentOutput, "///"), 10)
        << "Insufficient documentation comments in agent";

    // 2. Error handling coverage
    EXPECT_GT(CountPatternOccurrences(proxyOutput, "try {"), 1)
        << "Missing error handling in proxy";
    EXPECT_GT(CountPatternOccurrences(proxyOutput, "NetworkException"), 1)
        << "Missing NetworkException usage in proxy";

    // 3. Include completeness
    vector<string> requiredProxyIncludes = {
        "#include <KAI/Network/ProxyDecl.h>",
        "#include <functional>",
        "#include <RakNet/BitStream.h>"  
    };
    EXPECT_TRUE(ContainsPatterns(proxyOutput, requiredProxyIncludes))
        << "Missing required includes in proxy";

    vector<string> requiredAgentIncludes = {
        "#include <KAI/Network/AgentDecl.h>",
        "#include <RakNet/BitStream.h>"
    };
    EXPECT_TRUE(ContainsPatterns(agentOutput, requiredAgentIncludes))
        << "Missing required includes in agent";

    // 4. Header guard
    EXPECT_TRUE(proxyOutput.find("#pragma once") != string::npos)
        << "Missing #pragma once in proxy";
    EXPECT_TRUE(agentOutput.find("#pragma once") != string::npos)
        << "Missing #pragma once in agent";
}

// =============================================================================
// PERFORMANCE AND SCALABILITY TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, LargeInterfaceGeneration) {
    stringstream tauCode;
    tauCode << "namespace Large {\n";
    tauCode << "    interface IBigService {\n";
    
    // Generate 50 methods
    for (int i = 0; i < 50; ++i) {
        tauCode << "        int method" << i << "(string param" << i << ");\n";
    }
    
    // Generate 20 events
    for (int i = 0; i < 20; ++i) {
        tauCode << "        event Event" << i << "(int data" << i << ");\n";
    }
    
    tauCode << "    }\n";
    tauCode << "}\n";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode.str(), proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode.str(), agentOutput, error)) << "Agent Error: " << error;

    // Verify all methods and events are generated
    EXPECT_EQ(CountPatternOccurrences(proxyOutput, "/// Remote method call:"), 50)
        << "Should generate all 50 methods in proxy";
    EXPECT_EQ(CountPatternOccurrences(proxyOutput, "RegisterEvent"), 20)
        << "Should generate all 20 event registrations in proxy";
    
    EXPECT_EQ(CountPatternOccurrences(agentOutput, "void Handle_method"), 50)
        << "Should generate all 50 handlers in agent";
    EXPECT_EQ(CountPatternOccurrences(agentOutput, "void TriggerEvent"), 20)
        << "Should generate all 20 event triggers in agent";

    // Performance check - large interfaces should still be manageable
    EXPECT_LT(proxyOutput.length(), 100000) << "Proxy output seems excessively large";
    EXPECT_LT(agentOutput.length(), 100000) << "Agent output seems excessively large";
}

TEST_F(TauCodeGenerationExtensiveTests, DeepNestedNamespaces) {
    string tauCode = R"(
        namespace Level1::Level2::Level3::Level4::Level5 {
            interface IDeepService {
                void deepMethod();
                event DeepEvent(string data);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(tauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(tauCode, agentOutput, error)) << "Agent Error: " << error;

    // Verify deep namespaces are handled correctly
    EXPECT_TRUE(proxyOutput.find("namespace Level1::Level2::Level3::Level4::Level5") != string::npos)
        << "Proxy should handle deep namespaces:\n" << proxyOutput;
    EXPECT_TRUE(agentOutput.find("namespace Level1::Level2::Level3::Level4::Level5") != string::npos)
        << "Agent should handle deep namespaces:\n" << agentOutput;
}

// =============================================================================
// REGRESSION TESTS
// =============================================================================

TEST_F(TauCodeGenerationExtensiveTests, BackwardsCompatibility) {
    // Test that existing Tau code still generates correctly
    string legacyTauCode = R"(
        namespace Legacy {
            class OldService {
                void legacyMethod();
            }
            
            interface ILegacyInterface {
                int legacyCall(string data);
            }
        }
    )";

    string proxyOutput, agentOutput, error;
    ASSERT_TRUE(GenerateProxyCode(legacyTauCode, proxyOutput, error)) << "Proxy Error: " << error;
    ASSERT_TRUE(GenerateAgentCode(legacyTauCode, agentOutput, error)) << "Agent Error: " << error;

    // Should generate both class and interface
    EXPECT_TRUE(proxyOutput.find("class OldServiceProxy") != string::npos)
        << "Should generate proxy for legacy class";
    EXPECT_TRUE(proxyOutput.find("class ILegacyInterfaceProxy") != string::npos)
        << "Should generate proxy for legacy interface";
}

// =============================================================================
// MAIN TEST REGISTRATION
// =============================================================================

// Note: GTEST will automatically discover and run all TEST_F methods