#include <KAI/Core/BuiltinTypes.h>
#include <KAI/Core/File.h>
#include <KAI/Language/Tau/Generate/GenerateProcess.h>

#include <fstream>

using namespace std;

TAU_BEGIN

namespace Generate {

// Helper function to register minimal types needed for parsing
void RegisterMinimalTypes(Registry &reg) {
    // Register only the minimal types needed for Tau parsing
    // We don't need full type registration since we're not executing code
    reg.AddClass<void>(Label("Void"));
    reg.AddClass<bool>(Label("Bool"));
    reg.AddClass<int>(Label("Int"));
    reg.AddClass<float>(Label("Float"));
    reg.AddClass<String>(Label("String"));
    String::Register(reg);
    Label::Register(reg);
}

bool GenerateProcess::Generate(const char *input, string &output) {
    const auto parser = Parse(input);
    return parser && Generate(*parser, output);
}

shared_ptr<TauParser> GenerateProcess::Parse(const char *input) const {
    Registry r;
    RegisterMinimalTypes(r);

    auto lex = make_shared<TauLexer>(input, r);
    if (!lex->Process()) {
        Fail(lex->Error);
        return nullptr;
    }

    KAI_TRACE_1(lex->Print());

    auto parser = make_shared<TauParser>(r);
    // Use Structure::Module for top-level parsing
    if (!parser->Process(lex, Structure::Module)) {
        Fail(parser->Error);
        return nullptr;
    }

    return parser;
}

bool GenerateProcess::Generate(TauParser const &p, string &output) {
    if (!Module(p)) return false;

    stringstream str;
    str << CommonPrepend() << Prepend() << str_.str() << ends;
    output = str.str();
    return !Failed;
}

string GenerateProcess::CommonPrepend() {
    stringstream str;
    str << "// Auto-generated by KAI Tau IDL Code Generator\n";
    str << "// DO NOT MODIFY - Changes will be overwritten on next generation\n";
    str << "// Generated from Tau interface definition\n\n";
    str << "#pragma once\n\n";
    return str.str();
}

bool GenerateProcess::Module(TauParser const &p) {
    auto const &root = p.GetRoot();

    // Be more resilient with code generation - even if the module is empty
    if (root->GetChildren().empty()) {
        KAI_TRACE_WARN_1(
            "Empty module found, creating empty default namespace");
        StartBlock("namespace Default");
        EndBlock();
        return true;
    }

    // Start with a default namespace if none exists
    bool handledAnyNodes = false;

    for (const auto &ch : root->GetChildren()) {
        if (ch->GetType() == TauAstEnumType::Module) {
            // Handle module node
            for (const auto &moduleChild : ch->GetChildren()) {
                if (moduleChild->GetType() == TauAstEnumType::Namespace) {
                    if (!Namespace(*moduleChild)) {
                        // Continue even if namespace processing fails
                        KAI_TRACE_WARN_1(
                            "Namespace processing failed, but continuing");
                    }
                    handledAnyNodes = true;
                } else if (moduleChild->GetType() == TauAstEnumType::Class) {
                    // Check if this is actually a struct (has Struct child
                    // node)
                    bool isStruct = false;
                    for (const auto &child : moduleChild->GetChildren()) {
                        if (child->GetType() == TauAstEnumType::Struct) {
                            isStruct = true;
                            break;
                        }
                    }

                    // Directly handle class/struct without namespace
                    StartBlock("namespace Default");
                    if (isStruct) {
                        if (!Struct(*moduleChild)) {
                            // Continue even if struct processing fails
                            KAI_TRACE_WARN_1(
                                "Struct processing failed, but continuing");
                        }
                    } else {
                        if (!Class(*moduleChild)) {
                            // Continue even if class processing fails
                            KAI_TRACE_WARN_1(
                                "Class processing failed, but continuing");
                        }
                    }
                    EndBlock();
                    handledAnyNodes = true;
                } else {
                    // Log but continue - be more resilient to errors
                    KAI_TRACE_WARN_1(
                        "Unexpected node type in module, but continuing");
                }
            }
        } else if (ch->GetType() == TauAstEnumType::Namespace) {
            // Directly handle namespace node
            if (!Namespace(*ch)) {
                // Continue even if namespace processing fails
                KAI_TRACE_WARN_1("Namespace processing failed, but continuing");
            }
            handledAnyNodes = true;
        } else if (ch->GetType() == TauAstEnumType::Class) {
            // Check if this is actually a struct (has Struct child node)
            bool isStruct = false;
            for (const auto &child : ch->GetChildren()) {
                if (child->GetType() == TauAstEnumType::Struct) {
                    isStruct = true;
                    break;
                }
            }

            // Directly handle class/struct without namespace
            StartBlock("namespace Default");
            if (isStruct) {
                if (!Struct(*ch)) {
                    // Continue even if struct processing fails
                    KAI_TRACE_WARN_1(
                        "Struct processing failed, but continuing");
                }
            } else {
                if (!Class(*ch)) {
                    // Continue even if class processing fails
                    KAI_TRACE_WARN_1("Class processing failed, but continuing");
                }
            }
            EndBlock();
            handledAnyNodes = true;
        } else if (ch->GetType() == TauAstEnumType::Interface) {
            // Directly handle interface without namespace
            StartBlock("namespace Default");
            if (!Interface(*ch)) {
                // Continue even if interface processing fails
                KAI_TRACE_WARN_1("Interface processing failed, but continuing");
            }
            EndBlock();
            handledAnyNodes = true;
        } else {
            // Log but continue - be more resilient to errors
            KAI_TRACE_WARN_1("Unexpected node type at root, but continuing");
        }
    }

    if (!handledAnyNodes) {
        KAI_TRACE_WARN_1(
            "No valid Module, Namespace, or Class nodes found, creating empty "
            "default namespace");
        StartBlock("namespace Default");
        EndBlock();
        return true;
    }

    return true;
}

bool GenerateProcess::Namespace(Node const &ns) {
    StartBlock(string("namespace ") + ns.GetToken().Text());
    for (auto const &ch : ns.GetChildren()) {
        switch (ch->GetType()) {
            case TauAstEnumType::Namespace:
                if (!Namespace(*ch)) return false;
                break;

            case TauAstEnumType::Class:
                if (!Class(*ch)) return false;
                break;

            case TauAstEnumType::Interface:
                if (!Interface(*ch)) return false;
                break;

            default:
                // Skip unknown types for resilience
                break;
        }
    }

    EndBlock();
    return true;
}

bool GenerateProcess::Class(Node const &cl) {
    for (const auto &member : cl.GetChildren()) {
        switch (member->GetType()) {
            case TauAstEnumType::Class:
                return Class(*member);

            case TauAstEnumType::Property:
                if (!Property(*member)) return false;
                break;

            case TauAstEnumType::Method:
                if (!Method(*member)) return false;
                break;

            default:
                return Fail("Invalid class member: %s",
                            TauAstEnumType::ToString(member->GetType()));
        }
    }

    return true;
}

bool GenerateProcess::Property(Node const &prop) { return true; }

bool GenerateProcess::Method(Node const &method) { return true; }

string GenerateProcess::Prepend() const { return ""; }

stringstream &GenerateProcess::StartBlock(const string &name) {
    str_ << name << EndLine() << '{';
    indentation_++;
    str_ << EndLine();
    return str_;
}

string GenerateProcess::EndLine() const {
    stringstream s;
    s << "\n" << string(indentation_, '\t');
    return s.str();
}

void GenerateProcess::EndBlock() {
    indentation_--;
    str_ << EndLine() << '}';
}

bool GenerateProcess::Interface(Node const &interface) {
    // Default implementation - derived classes should override
    // For now, treat interfaces like classes
    return Class(interface);
}

bool GenerateProcess::Struct(Node const &strct) {
    // Default implementation - derived classes should override
    // For now, treat structs like classes
    return Class(strct);
}

}  // namespace Generate

TAU_END
